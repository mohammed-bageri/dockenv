package utils

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	yaml "gopkg.in/yaml.v3"

	"github.com/mohammed-bageri/dockenv/internal/config"
)

func FileExists(filename string) bool {
	_, err := os.Stat(filename)
	return err == nil
}

func LoadConfig() (*config.Config, error) {
	configPath := config.GetConfigPath()

	if !FileExists(configPath) {
		return &config.Config{
			Version:  "1.0",
			Services: []string{},
			Ports:    make(map[string]int),
			Env:      make(map[string]string),
			Volumes:  make(map[string]string),
			DataPath: config.GetDataPath(),
		}, nil
	}

	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	var cfg config.Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, fmt.Errorf("failed to parse config file: %w", err)
	}

	// Ensure maps are initialized
	if cfg.Ports == nil {
		cfg.Ports = make(map[string]int)
	}
	if cfg.Env == nil {
		cfg.Env = make(map[string]string)
	}
	if cfg.Volumes == nil {
		cfg.Volumes = make(map[string]string)
	}
	if cfg.DataPath == "" {
		cfg.DataPath = config.GetDataPath()
	}

	return &cfg, nil
}

func SaveConfig(cfg *config.Config) error {
	if err := config.EnsureConfigDir(); err != nil {
		return err
	}

	configPath := config.GetConfigPath()
	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	if err := os.WriteFile(configPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}

func GenerateFromTemplate(templateName string, data interface{}, outputPath string) error {
	templatePath := filepath.Join("templates", templateName)

	tmpl, err := template.ParseFiles(templatePath)
	if err != nil {
		return fmt.Errorf("failed to parse template %s: %w", templateName, err)
	}

	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file %s: %w", outputPath, err)
	}
	defer outputFile.Close()

	if err := tmpl.Execute(outputFile, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

func CopyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = io.Copy(dstFile, srcFile)
	return err
}

func CreateEnvFile(envVars map[string]string) error {
	envPath := config.EnvFileName
	err := updateEnvFile(envPath, envVars, true)
	if err != nil {
		return err
	}

	// Also update .env.example if it exists
	examplePath := ".env.example"
	if FileExists(examplePath) {
		// For .env.example, we'll use placeholder values
		exampleVars := make(map[string]string)
		for key, value := range envVars {
			// Create example values (remove sensitive data)
			switch {
			case strings.Contains(strings.ToLower(key), "password"):
				exampleVars[key] = "your_password_here"
			case strings.Contains(strings.ToLower(key), "secret"):
				exampleVars[key] = "your_secret_here"
			case strings.Contains(strings.ToLower(key), "key") && !strings.Contains(strings.ToLower(key), "port"):
				exampleVars[key] = "your_key_here"
			case strings.Contains(strings.ToLower(key), "token"):
				exampleVars[key] = "your_token_here"
			default:
				exampleVars[key] = value
			}
		}
		return updateEnvFile(examplePath, exampleVars, false)
	}

	return nil
}

func updateEnvFile(filePath string, newVars map[string]string, addHeader bool) error {
	// Parse existing env file if it exists
	existingVars := make(map[string]string)
	var comments []string
	var order []string

	if FileExists(filePath) {
		file, err := os.Open(filePath)
		if err != nil {
			return fmt.Errorf("failed to open existing env file: %w", err)
		}
		defer file.Close()

		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			line := strings.TrimSpace(scanner.Text())

			// Skip empty lines and comments (except preserve non-generated comments)
			if line == "" || (strings.HasPrefix(line, "#") && !strings.Contains(line, "Generated by dockenv")) {
				if line != "" && !strings.Contains(line, "Generated by dockenv") && !strings.Contains(line, "Environment variables for development services") {
					comments = append(comments, line)
				}
				continue
			}

			// Parse key=value pairs
			if strings.Contains(line, "=") && !strings.HasPrefix(line, "#") {
				parts := strings.SplitN(line, "=", 2)
				if len(parts) == 2 {
					key := strings.TrimSpace(parts[0])
					value := strings.TrimSpace(parts[1])
					existingVars[key] = value

					// Track order of existing keys
					if !Contains(order, key) {
						order = append(order, key)
					}
				}
			}
		}

		if err := scanner.Err(); err != nil {
			return fmt.Errorf("failed to read env file: %w", err)
		}
	}

	// Merge new variables with existing ones
	for key, value := range newVars {
		existingVars[key] = value
		// Add new keys to order if they don't exist
		if !Contains(order, key) {
			order = append(order, key)
		}
	}

	// Write the updated env file
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create env file: %w", err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)

	// Write preserved comments first
	for _, comment := range comments {
		fmt.Fprintln(writer, comment)
	}
	if len(comments) > 0 {
		fmt.Fprintln(writer, "")
	}

	// Write environment variables in the preserved order
	for _, key := range order {
		if value, exists := existingVars[key]; exists {
			fmt.Fprintf(writer, "%s=%s\n", key, value)
		}
	}

	return writer.Flush()
}

func DetectProjectType() string {
	// Laravel
	if FileExists("artisan") && FileExists("composer.json") {
		return "laravel"
	}

	// Node.js
	if FileExists("package.json") {
		return "node"
	}

	// Django
	if FileExists("manage.py") {
		return "django"
	}

	// Rails
	if FileExists("Gemfile") && FileExists("config.ru") {
		return "rails"
	}

	// Spring Boot
	if FileExists("pom.xml") || FileExists("build.gradle") {
		return "spring"
	}

	return "unknown"
}

func PromptConfirm(message string) bool {
	fmt.Printf("%s (y/N): ", message)

	var response string
	_, _ = fmt.Scanln(&response)

	response = strings.ToLower(strings.TrimSpace(response))
	return response == "y" || response == "yes"
}

func Contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func RemoveString(slice []string, item string) []string {
	var result []string
	for _, s := range slice {
		if s != item {
			result = append(result, s)
		}
	}
	return result
}
